Systems Programming Experiences
--------------------------------------------------------------------------------
Group 2:
Daniel Meiller
Benjamin Maitland
Brennan Ringey
Nathan Castle

Daniel Meiller
--------------------------------------------------------------------------------
Over the course of this project, I had lots of problems arising from the
compiler. I had weird problems where including a function in a compilation would
cause either bootlooping or weird things to execute and display on the screen.
Even putting a panic or x86 hlt early wouldn't stop it from bootlooping. This
was very hard to debug, and I spent lots of time trying to figure these issues,
when I would've liked to work on the actually networking/programming aspect of
the project. I attempted to use the Windows Subsystem for Linux and gcc-6.2 as
well as an Ubuntu 17.04 vm, with both gcc-6.3 and gcc-5.4. If I had to do this
again I would install an LTS ubuntu version native onto my computer, as it would
make everything more simple. 

Because nobody in our group worked on a shell, we had to rely on recompiling
the OS and using different flags when we wanted to test the different modules.
This worked fine, but meant that our ability to demo things was relatively
limited.

For the networking portion I worked on, the biggest things that bit me we
network byte order, and struct alignment. I initially started using uint8_t[]
for most of the multi-byte data I needed to send and receive through the
network. I switched to using native little endian in my code, and just
converting to network byte order when interfacing on the network. I discovered a
built in gcc function called __builtin_bswap32(), as well as the 16-bit varient.
This were really useful, as I didn't have to write and test my own function 
(however simple it may have been). 

I had issues with synchronization, which led me away from some of the things I
would've liked to get working. An example is ICMP echo replies. This in theory
would be easy to implement, but I had the issue of possibly needing to make an
ARP request while trying to respond to the echo. Since my receive daemon would
be handling the ICMP echo at that time, it wouldn't be able to process received
data and get the ARP entry that was needed. This could be fixed by adding
another layer, where the daemon spawns other processes to deal with accepting
ARP packets, or responding to pings, or putting data into queues for users to
receive. This would lead to synchronization issues, and fixing these were beyond
the scope of what I was trying to do. Because of these issues, I also avoided
using system calls, as I needed to be able to utilize interrupts within these
functions.

Benjamin Maitland
--------------------------------------------------------------------------------


Brennan Ringey
--------------------------------------------------------------------------------


Nathan Castle
--------------------------------------------------------------------------------

